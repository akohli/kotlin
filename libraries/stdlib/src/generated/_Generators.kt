package kotlin

//
// NOTE THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//

import java.util.*

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun <T> Array<T>.partition(predicate: (T) -> Boolean) : Pair<List<T>, List<T>> {
    val first = ArrayList<T>()
    val second = ArrayList<T>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun BooleanArray.partition(predicate: (Boolean) -> Boolean) : Pair<List<Boolean>, List<Boolean>> {
    val first = ArrayList<Boolean>()
    val second = ArrayList<Boolean>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun ByteArray.partition(predicate: (Byte) -> Boolean) : Pair<List<Byte>, List<Byte>> {
    val first = ArrayList<Byte>()
    val second = ArrayList<Byte>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun CharArray.partition(predicate: (Char) -> Boolean) : Pair<List<Char>, List<Char>> {
    val first = ArrayList<Char>()
    val second = ArrayList<Char>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun DoubleArray.partition(predicate: (Double) -> Boolean) : Pair<List<Double>, List<Double>> {
    val first = ArrayList<Double>()
    val second = ArrayList<Double>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun FloatArray.partition(predicate: (Float) -> Boolean) : Pair<List<Float>, List<Float>> {
    val first = ArrayList<Float>()
    val second = ArrayList<Float>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun IntArray.partition(predicate: (Int) -> Boolean) : Pair<List<Int>, List<Int>> {
    val first = ArrayList<Int>()
    val second = ArrayList<Int>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun LongArray.partition(predicate: (Long) -> Boolean) : Pair<List<Long>, List<Long>> {
    val first = ArrayList<Long>()
    val second = ArrayList<Long>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun ShortArray.partition(predicate: (Short) -> Boolean) : Pair<List<Short>, List<Short>> {
    val first = ArrayList<Short>()
    val second = ArrayList<Short>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun <T> Iterable<T>.partition(predicate: (T) -> Boolean) : Pair<List<T>, List<T>> {
    val first = ArrayList<T>()
    val second = ArrayList<T>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Splits original collection into pair of collections,
 * where *first* collection contains elements for which predicate yielded *true*,
 * while *second* collection contains elements for which predicate yielded *false*
 */
public fun <T> Stream<T>.partition(predicate: (T) -> Boolean) : Pair<List<T>, List<T>> {
    val first = ArrayList<T>()
    val second = ArrayList<T>()
    for (element in this) {
        if (predicate(element)) {
            first.add(element)
        } else {
            second.add(element)
        }
    }
    return Pair(first, second)
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun <T> Array<T>.plus(collection: Iterable<T>) : List<T> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun BooleanArray.plus(collection: Iterable<Boolean>) : List<Boolean> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun ByteArray.plus(collection: Iterable<Byte>) : List<Byte> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun CharArray.plus(collection: Iterable<Char>) : List<Char> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun DoubleArray.plus(collection: Iterable<Double>) : List<Double> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun FloatArray.plus(collection: Iterable<Float>) : List<Float> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun IntArray.plus(collection: Iterable<Int>) : List<Int> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun LongArray.plus(collection: Iterable<Long>) : List<Long> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun ShortArray.plus(collection: Iterable<Short>) : List<Short> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then all elements of the given *collection*
 */
public fun <T> Iterable<T>.plus(collection: Iterable<T>) : List<T> {
    val answer = toArrayList()
    answer.addAll(collection)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun <T> Array<T>.plus(element: T) : List<T> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun BooleanArray.plus(element: Boolean) : List<Boolean> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun ByteArray.plus(element: Byte) : List<Byte> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun CharArray.plus(element: Char) : List<Char> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun DoubleArray.plus(element: Double) : List<Double> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun FloatArray.plus(element: Float) : List<Float> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun IntArray.plus(element: Int) : List<Int> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun LongArray.plus(element: Long) : List<Long> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun ShortArray.plus(element: Short) : List<Short> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a list containing all elements of original collection and then the given element
 */
public fun <T> Iterable<T>.plus(element: T) : List<T> {
    val answer = toArrayList()
    answer.add(element)
    return answer
    
}

/**
 * Returns a stream containing all elements of original stream and then the given element
 */
public fun <T> Stream<T>.plus(element: T) : Stream<T> {
    val answer = toArrayList()
    answer.add(element)
    return answer.stream()
    
}

/**
 * Returns a stream containing all elements of original stream and then all elements of the given *stream*
 */
public fun <T> Stream<T>.plus(stream: Stream<T>) : Stream<T> {
    val answer = toArrayList()
    answer.addAll(stream)
    return answer.stream()
    
}

