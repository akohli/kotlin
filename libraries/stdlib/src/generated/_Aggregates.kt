package kotlin

//
// NOTE THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//

import java.util.*

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun <T> Stream<T>.all(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun <T> Iterable<T>.all(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun <T> Array<T>.all(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun ByteArray.all(predicate: (Byte) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun CharArray.all(predicate: (Char) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun DoubleArray.all(predicate: (Double) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun LongArray.all(predicate: (Long) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun IntArray.all(predicate: (Int) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun ShortArray.all(predicate: (Short) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun BooleanArray.all(predicate: (Boolean) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if all elements match the given *predicate*
 */
public fun FloatArray.all(predicate: (Float) -> Boolean) : Boolean {
    for (element in this) if (!predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun <T> Stream<T>.any(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun <T> Iterable<T>.any(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun <T> Array<T>.any(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun ByteArray.any(predicate: (Byte) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun CharArray.any(predicate: (Char) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun DoubleArray.any(predicate: (Double) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun LongArray.any(predicate: (Long) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun IntArray.any(predicate: (Int) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun ShortArray.any(predicate: (Short) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun BooleanArray.any(predicate: (Boolean) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Returns *true* if any elements match the given *predicate*
 */
public fun FloatArray.any(predicate: (Float) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return true
    return false
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun <T> Stream<T>.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun <T> Iterable<T>.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun <T> Array<T>.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun ByteArray.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun CharArray.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun DoubleArray.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun LongArray.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun IntArray.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun ShortArray.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun BooleanArray.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Appends the string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun FloatArray.appendString(buffer: Appendable, separator: String = ", ", prefix: String ="", postfix: String = "", limit: Int = -1, truncated: String = "...") : Unit {
    buffer.append(prefix)
    var count = 0
    for (element in this) {
        if (++count > 1) buffer.append(separator)
        if (limit < 0 || count <= limit) {
            val text = if (element == null) "null" else element.toString()
            buffer.append(text)
        } else break
    }
    if (limit >= 0 && count > limit) buffer.append(truncated)
    buffer.append(postfix)
    
}

/**
 * Returns the number of elements
 */
public fun <T> Stream<T>.count() : Int {
    var count = 0
    for (element in this) count++
    return count
    
}

/**
 * Returns the number of elements
 */
public fun <T> Iterable<T>.count() : Int {
    var count = 0
    for (element in this) count++
    return count
    
}

/**
 * Returns the number of elements
 */
public fun <T> Collection<T>.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun <T> Array<T>.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun ByteArray.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun CharArray.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun DoubleArray.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun LongArray.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun IntArray.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun ShortArray.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun BooleanArray.count() : Int {
    return size
}

/**
 * Returns the number of elements
 */
public fun FloatArray.count() : Int {
    return size
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun <T> Stream<T>.count(predicate: (T) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun <T> Iterable<T>.count(predicate: (T) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun <T> Array<T>.count(predicate: (T) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun ByteArray.count(predicate: (Byte) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun CharArray.count(predicate: (Char) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun DoubleArray.count(predicate: (Double) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun LongArray.count(predicate: (Long) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun IntArray.count(predicate: (Int) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun ShortArray.count(predicate: (Short) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun BooleanArray.count(predicate: (Boolean) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Returns the number of elements matching the given *predicate*
 */
public fun FloatArray.count(predicate: (Float) -> Boolean) : Int {
    var count = 0
    for (element in this) if (predicate(element)) count++
    return count
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <T, R> Stream<T>.fold(initial: R, operation: (R, T) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <T, R> Iterable<T>.fold(initial: R, operation: (R, T) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <T, R> Array<T>.fold(initial: R, operation: (R, T) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <R> ByteArray.fold(initial: R, operation: (R, Byte) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <R> CharArray.fold(initial: R, operation: (R, Char) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <R> DoubleArray.fold(initial: R, operation: (R, Double) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <R> LongArray.fold(initial: R, operation: (R, Long) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <R> IntArray.fold(initial: R, operation: (R, Int) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <R> ShortArray.fold(initial: R, operation: (R, Short) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <R> BooleanArray.fold(initial: R, operation: (R, Boolean) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Folds all elements from from left to right with the *initial* value to perform the operation on sequential pairs of elements
 */
public fun <R> FloatArray.fold(initial: R, operation: (R, Float) -> R) : R {
    var answer = initial
    for (element in this) answer = operation(answer, element)
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <T, R> List<T>.foldRight(initial: R, operation: (R, T) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <T, R> Array<T>.foldRight(initial: R, operation: (R, T) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <R> ByteArray.foldRight(initial: R, operation: (R, Byte) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <R> CharArray.foldRight(initial: R, operation: (R, Char) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <R> DoubleArray.foldRight(initial: R, operation: (R, Double) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <R> LongArray.foldRight(initial: R, operation: (R, Long) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <R> IntArray.foldRight(initial: R, operation: (R, Int) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <R> ShortArray.foldRight(initial: R, operation: (R, Short) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <R> BooleanArray.foldRight(initial: R, operation: (R, Boolean) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <R> FloatArray.foldRight(initial: R, operation: (R, Float) -> R) : R {
    var index = size - 1
    if (index < 0) throw UnsupportedOperationException("Empty iterable can't be reduced")
    var answer = initial
    while (index >= 0) {
        answer = operation(answer, get(index--))
    }
    return answer
    
}

/**
 * Performs the given *operation* on each element
 */
public fun <T> Stream<T>.forEach(operation: (T) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun <T> Iterable<T>.forEach(operation: (T) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun <T> Array<T>.forEach(operation: (T) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun ByteArray.forEach(operation: (Byte) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun CharArray.forEach(operation: (Char) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun DoubleArray.forEach(operation: (Double) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun LongArray.forEach(operation: (Long) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun IntArray.forEach(operation: (Int) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun ShortArray.forEach(operation: (Short) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun BooleanArray.forEach(operation: (Boolean) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Performs the given *operation* on each element
 */
public fun FloatArray.forEach(operation: (Float) -> Unit) : Unit {
    for (element in this) operation(element)
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun <T> Stream<T>.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun <T> Iterable<T>.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun <T> Array<T>.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun ByteArray.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun CharArray.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun DoubleArray.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun LongArray.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun IntArray.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun ShortArray.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun BooleanArray.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Creates a string from all the elements separated using the *separator* and using the given *prefix* and *postfix* if supplied.
 * If a collection could be huge you can specify a non-negative value of *limit* which will only show a subset of the collection then it will
 * a special *truncated* separator (which defaults to "..."
 */
public fun FloatArray.makeString(separator: String = ", ", prefix: String = "", postfix: String = "", limit: Int = -1, truncated: String = "...") : String {
    val buffer = StringBuilder()
    appendString(buffer, separator, prefix, postfix, limit, truncated)
    return buffer.toString()
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun <T: Comparable<T>> Stream<T>.max() : T? {
    val iterator = iterator()
    if (!iterator.hasNext()) return null
    
    var max = iterator.next()
    while (iterator.hasNext()) {
        val e = iterator.next()
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun <T: Comparable<T>> Iterable<T>.max() : T? {
    val iterator = iterator()
    if (!iterator.hasNext()) return null
    
    var max = iterator.next()
    while (iterator.hasNext()) {
        val e = iterator.next()
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun <T: Comparable<T>> Array<T>.max() : T? {
    if (isEmpty()) return null
    
    var max = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun ByteArray.max() : Byte? {
    if (isEmpty()) return null
    
    var max = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun CharArray.max() : Char? {
    if (isEmpty()) return null
    
    var max = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun DoubleArray.max() : Double? {
    if (isEmpty()) return null
    
    var max = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun LongArray.max() : Long? {
    if (isEmpty()) return null
    
    var max = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun IntArray.max() : Int? {
    if (isEmpty()) return null
    
    var max = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun ShortArray.max() : Short? {
    if (isEmpty()) return null
    
    var max = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the largest element or null if there are no elements
 */
public fun FloatArray.max() : Float? {
    if (isEmpty()) return null
    
    var max = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (max < e) max = e
    }
    return max
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>, T: Any> Stream<T>.maxBy(f: (T) -> R) : T? {
    val iterator = iterator()
    if (!iterator.hasNext()) return null
    
    var maxElem = iterator.next()
    var maxValue = f(maxElem)
    while (iterator.hasNext()) {
        val e = iterator.next()
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>, T: Any> Iterable<T>.maxBy(f: (T) -> R) : T? {
    val iterator = iterator()
    if (!iterator.hasNext()) return null
    
    var maxElem = iterator.next()
    var maxValue = f(maxElem)
    while (iterator.hasNext()) {
        val e = iterator.next()
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>, T: Any> Array<T>.maxBy(f: (T) -> R) : T? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> ByteArray.maxBy(f: (Byte) -> R) : Byte? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> CharArray.maxBy(f: (Char) -> R) : Char? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> DoubleArray.maxBy(f: (Double) -> R) : Double? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> LongArray.maxBy(f: (Long) -> R) : Long? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> IntArray.maxBy(f: (Int) -> R) : Int? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> ShortArray.maxBy(f: (Short) -> R) : Short? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> BooleanArray.maxBy(f: (Boolean) -> R) : Boolean? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the first element yielding the largest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> FloatArray.maxBy(f: (Float) -> R) : Float? {
    if (isEmpty()) return null
    
    var maxElem = this[0]
    var maxValue = f(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (maxValue < v) {
           maxElem = e
           maxValue = v
        }
    }
    return maxElem
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun <T: Comparable<T>> Stream<T>.min() : T? {
    val iterator = iterator()
    if (!iterator.hasNext()) return null
    
    var min = iterator.next()
    while (iterator.hasNext()) {
        val e = iterator.next()
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun <T: Comparable<T>> Iterable<T>.min() : T? {
    val iterator = iterator()
    if (!iterator.hasNext()) return null
    
    var min = iterator.next()
    while (iterator.hasNext()) {
        val e = iterator.next()
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun <T: Comparable<T>> Array<T>.min() : T? {
    if (isEmpty()) return null
    var min = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun ByteArray.min() : Byte? {
    if (isEmpty()) return null
    var min = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun CharArray.min() : Char? {
    if (isEmpty()) return null
    var min = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun DoubleArray.min() : Double? {
    if (isEmpty()) return null
    var min = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun LongArray.min() : Long? {
    if (isEmpty()) return null
    var min = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun IntArray.min() : Int? {
    if (isEmpty()) return null
    var min = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun ShortArray.min() : Short? {
    if (isEmpty()) return null
    var min = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the smallest element or null if there are no elements
 */
public fun FloatArray.min() : Float? {
    if (isEmpty()) return null
    var min = this[0]
    for (i in 1..lastIndex) {
        val e = this[i]
        if (min > e) min = e
    }
    return min
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>, T: Any> Stream<T>.minBy(f: (T) -> R) : T? {
    val iterator = iterator()
    if (!iterator.hasNext()) return null
    
    var minElem = iterator.next()
    var minValue = f(minElem)
    while (iterator.hasNext()) {
        val e = iterator.next()
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>, T: Any> Iterable<T>.minBy(f: (T) -> R) : T? {
    val iterator = iterator()
    if (!iterator.hasNext()) return null
    
    var minElem = iterator.next()
    var minValue = f(minElem)
    while (iterator.hasNext()) {
        val e = iterator.next()
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>, T: Any> Array<T>.minBy(f: (T) -> R) : T? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> ByteArray.minBy(f: (Byte) -> R) : Byte? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> CharArray.minBy(f: (Char) -> R) : Char? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> DoubleArray.minBy(f: (Double) -> R) : Double? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> LongArray.minBy(f: (Long) -> R) : Long? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> IntArray.minBy(f: (Int) -> R) : Int? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> ShortArray.minBy(f: (Short) -> R) : Short? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> BooleanArray.minBy(f: (Boolean) -> R) : Boolean? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns the first element yielding the smallest value of the given function or null if there are no elements
 */
public fun <R: Comparable<R>> FloatArray.minBy(f: (Float) -> R) : Float? {
    if (size == 0) return null
    
    var minElem = this[0]
    var minValue = f(minElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = f(e)
        if (minValue > v) {
           minElem = e
           minValue = v
        }
    }
    return minElem
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun <T> Stream<T>.none(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun <T> Iterable<T>.none(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun <T> Array<T>.none(predicate: (T) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun ByteArray.none(predicate: (Byte) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun CharArray.none(predicate: (Char) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun DoubleArray.none(predicate: (Double) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun LongArray.none(predicate: (Long) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun IntArray.none(predicate: (Int) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun ShortArray.none(predicate: (Short) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun BooleanArray.none(predicate: (Boolean) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Returns *true* if no elements match the given *predicate*
 */
public fun FloatArray.none(predicate: (Float) -> Boolean) : Boolean {
    for (element in this) if (predicate(element)) return false
    return true
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun <T> Stream<T>.reduce(operation: (T, T) -> T) : T {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: T = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun <T> Iterable<T>.reduce(operation: (T, T) -> T) : T {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: T = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun <T> Array<T>.reduce(operation: (T, T) -> T) : T {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: T = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun ByteArray.reduce(operation: (Byte, Byte) -> Byte) : Byte {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: Byte = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun CharArray.reduce(operation: (Char, Char) -> Char) : Char {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: Char = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun DoubleArray.reduce(operation: (Double, Double) -> Double) : Double {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: Double = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun LongArray.reduce(operation: (Long, Long) -> Long) : Long {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: Long = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun IntArray.reduce(operation: (Int, Int) -> Int) : Int {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: Int = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun ShortArray.reduce(operation: (Short, Short) -> Short) : Short {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: Short = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun BooleanArray.reduce(operation: (Boolean, Boolean) -> Boolean) : Boolean {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: Boolean = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from left to right.
 * Similar to fold function, but uses the first element as initial value
 */
public fun FloatArray.reduce(operation: (Float, Float) -> Float) : Float {
    val iterator = this.iterator()
    if (!iterator.hasNext()) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var result: Float = iterator.next() //compiler doesn't understand that result will initialized anyway
    while (iterator.hasNext()) {
        result = operation(result, iterator.next())
    }
    return result
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <T> List<T>.reduceRight(operation: (T, T) -> T) : T {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun <T> Array<T>.reduceRight(operation: (T, T) -> T) : T {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun ByteArray.reduceRight(operation: (Byte, Byte) -> Byte) : Byte {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun CharArray.reduceRight(operation: (Char, Char) -> Char) : Char {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun DoubleArray.reduceRight(operation: (Double, Double) -> Double) : Double {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun LongArray.reduceRight(operation: (Long, Long) -> Long) : Long {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun IntArray.reduceRight(operation: (Int, Int) -> Int) : Int {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun ShortArray.reduceRight(operation: (Short, Short) -> Short) : Short {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun BooleanArray.reduceRight(operation: (Boolean, Boolean) -> Boolean) : Boolean {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

/**
 * Applies binary operation to all elements of iterable, going from right to left.
 * Similar to foldRight function, but uses the last element as initial value
 */
public fun FloatArray.reduceRight(operation: (Float, Float) -> Float) : Float {
    var index = size - 1
    if (index < 0) {
        throw UnsupportedOperationException("Empty iterable can't be reduced")
    }
    
    var r = get(index--)
    while (index >= 0) {
        r = operation(get(index--), r)
    }
    
    return r
    
}

